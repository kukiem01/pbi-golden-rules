1) POWER QUERY (BACKEND — ETL)
GOAL: Maintainable, readable, and performant transformation logic with clear lineage.

IMPORTANT (PBIX reality):
- For tables loaded to the model, the Power Query query name and the model table name are effectively the same.
- Therefore:
  * Use TECHNICAL prefixes only for NON-LOADED queries (Raw_, Stg_, DOC_).
  * Use BUSINESS-FRIENDLY names for LOADED tables (facts, dimensions, and user-facing UI tables).
- Use Query Groups (folders) to represent layers (Raw/Staging/Model/UI) instead of prefixes on loaded tables.

Folder structure (Query Groups):
00_Raw_Source
  - Raw data connections / entry points (minimal transforms)
10_Staging
  - Intermediate transforms (cleaning/shaping/joining), typically referenced by final queries
20_Model
  - Final analytical tables loaded into the model (BUSINESS names)
30_Support_UI
  - Support/UI tables (slicers, parameters, helper lists) — business names if user-facing

Query naming conventions:
Non-loaded technical query prefixes (Enable Load = Off):
- Raw_* : external source entry queries
- Stg_* : staging / intermediate queries
- DOC_* : documentation queries

Loaded tables (Enable Load = On):
- Use business-friendly names (Title Case with spaces).
- Avoid technical prefixes like Fact_/Dim_ in names visible in the Fields list.

Recommended pattern (non-loaded queries):
<Prefix>_<CoreName>[_<TransformSuffix>]
Examples:
- Raw_SalesOrders
- Stg_SalesOrders_Clean
- Stg_SalesOrders_Shaped
- Sales Orders  (final loaded table; business name)

Loading rules:
- Disable 'Enable Load' for Raw_*, Stg_*, DOC_* and helpers not meant to be model tables.
- Enable load only for final analytical tables and UI tables that must exist in the model.

UI/helper tables from external sources (e.g., Excel on SharePoint):
- Recommended: create a Raw_* entry query in 00_Raw_Source (load off), then Reference into a final UI table in 30_Support_UI.
- Use Stg_* only when transformations are non-trivial or reused.

Inline helper tables (no external source):
- If a helper/UI table is fully defined in M (e.g., Table.FromRows / compressed payload), place it directly in 30_Support_UI as UI_* or a business name.
- Split into Stg_ + final UI only if the inline payload is large or you want to separate 'raw inline data' from transforms.

Performance & reliability:
- Filter early: remove unnecessary rows/columns as soon as possible
- Preserve query folding where possible (push transforms to the source)
- Apply expensive operations late (sort, group, pivot, merge-heavy steps)
- Prefer Reference over Duplicate to avoid repeating heavy logic
- Set correct data types early enough to prevent surprises, but avoid breaking folding unnecessarily
- Use parameters for environment-specific items (server, warehouse, paths) where appropriate

DirectQuery guidance (especially important for Databricks):
- In DirectQuery, transformations must fold back to the source; non-foldable steps may be unsupported or lead to failures/performance issues.
- Staging (Raw -> Stg -> Final) is OK ONLY if the final loaded query still folds into a single native query.
- Reference does NOT inherently break folding; non-foldable steps do.
- Keep PQ transformations minimal and 'fold-friendly' in DirectQuery.
- Move heavy shaping upstream (Databricks view/materialization) when PQ steps get complex or folding becomes fragile.

How to validate folding (don’t guess):
- Use Query Plan and/or Query Diagnostics; also monitor source-side query history (e.g., Databricks SQL Warehouse).
- 'View Native Query' availability can be connector-dependent; diagnostics are more reliable.
